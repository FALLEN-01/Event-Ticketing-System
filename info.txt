# ğŸš€ Project Overview

**Name:** Smart Event Ticketing & Verification System
**Goal:** Manage event registrations, issue digital QR tickets, and verify them using a Flutter scanning app.
**Phase-1 Focus:** Local development using SQLite/Postgres, with Flutter scanner and admin dashboard.

---

# ğŸ§© 1. Tech Stack

| Layer                                      | Tool/Framework                        | Purpose                                                                          |
| ------------------------------------------ | ------------------------------------- | -------------------------------------------------------------------------------- |
| **Frontend (User Form & Admin Dashboard)** | React + Vite + TailwindCSS            | Modern, fast UI for both registration and admin control                          |
| **Backend**                                | FastAPI (Python)                      | REST API for form submissions, approvals, QR generation, and ticket verification |
| **Database (local)**                       | SQLite (dev) / PostgreSQL (prod)      | Persistent data storage                                                          |
| **QR Generation**                          | `qrcode` Python lib                   | Generate QR PNGs for tickets                                                     |
| **Object Storage (future)**                | Local `/uploads/` â†’ later S3/Supabase | Store QR images or screenshots                                                   |
| **Authentication**                         | JWT (FastAPI + `python-jose`)         | Admin login security                                                             |
| **Mobile App**                             | Flutter                               | QR scanner + fallback manual entry                                               |
| **State Management (Flutter)**             | Provider / Riverpod                   | Manage scanning state                                                            |
| **Deployment**                             | Docker + docker-compose               | Containerized environment for easy setup                                         |

---

# ğŸ—‚ï¸ 2. Full Folder Structure

```
event-ticketing-system/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py                # FastAPI entry point
â”‚   â”œâ”€â”€ requirements.txt       # Backend dependencies
â”‚   â”œâ”€â”€ .env                   # Environment variables (DB URL, JWT secret)
â”‚   â”‚
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ database.py        # SQLAlchemy setup (SQLite/Postgres)
â”‚   â”‚   â”œâ”€â”€ models/            # ORM Models
â”‚   â”‚   â”‚   â”œâ”€â”€ registration.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ticket.py
â”‚   â”‚   â”‚   â”œâ”€â”€ attachment.py
â”‚   â”‚   â”‚   â”œâ”€â”€ admin.py
â”‚   â”‚   â”‚   â””â”€â”€ audit_log.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ schemas/           # Pydantic request/response models
â”‚   â”‚   â”‚   â”œâ”€â”€ registration_schema.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ticket_schema.py
â”‚   â”‚   â”‚   â””â”€â”€ admin_schema.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ routes/            # API Endpoints
â”‚   â”‚   â”‚   â”œâ”€â”€ registration_routes.py
â”‚   â”‚   â”‚   â”œâ”€â”€ admin_routes.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ticket_routes.py
â”‚   â”‚   â”‚   â””â”€â”€ auth_routes.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/          # Core business logic
â”‚   â”‚   â”‚   â”œâ”€â”€ qr_service.py
â”‚   â”‚   â”‚   â”œâ”€â”€ email_service.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ticket_service.py
â”‚   â”‚   â”‚   â””â”€â”€ verification_service.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ utils/             # Helper functions
â”‚   â”‚   â”‚   â”œâ”€â”€ security.py
â”‚   â”‚   â”‚   â”œâ”€â”€ serial_generator.py
â”‚   â”‚   â”‚   â””â”€â”€ storage.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ static/uploads/    # Local file uploads (dev)
â”‚   â”‚   â””â”€â”€ templates/         # Email templates (future)
â”‚   â”‚
â”‚   â”œâ”€â”€ alembic/               # DB migrations
â”‚   â””â”€â”€ alembic.ini
â”‚
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ form-app/              # User registration form
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ vite.config.js
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ main.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RegistrationForm.jsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ SuccessMessage.jsx
â”‚   â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Home.jsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ About.jsx
â”‚   â”‚   â”‚   â””â”€â”€ api/
â”‚   â”‚   â”‚       â””â”€â”€ registrationApi.js
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”‚
â”‚   â””â”€â”€ admin-dashboard/       # Admin panel for approvals
â”‚       â”œâ”€â”€ index.html
â”‚       â”œâ”€â”€ vite.config.js
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ main.jsx
â”‚       â”‚   â”œâ”€â”€ components/
â”‚       â”‚   â”‚   â”œâ”€â”€ Sidebar.jsx
â”‚       â”‚   â”‚   â”œâ”€â”€ Navbar.jsx
â”‚       â”‚   â”‚   â”œâ”€â”€ Table.jsx
â”‚       â”‚   â”‚   â””â”€â”€ ApproveModal.jsx
â”‚       â”‚   â”œâ”€â”€ pages/
â”‚       â”‚   â”‚   â”œâ”€â”€ Dashboard.jsx
â”‚       â”‚   â”‚   â””â”€â”€ Login.jsx
â”‚       â”‚   â””â”€â”€ api/
â”‚       â”‚       â””â”€â”€ adminApi.js
â”‚       â””â”€â”€ package.json
â”‚
â”‚
â”œâ”€â”€ flutter-app/
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ main.dart
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â”œâ”€â”€ scan_page.dart         # QR scanning window
â”‚   â”‚   â”‚   â”œâ”€â”€ verify_result.dart     # Shows ticket details
â”‚   â”‚   â”‚   â””â”€â”€ manual_entry.dart      # Fallback serial entry
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ api_service.dart       # Backend API calls
â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â””â”€â”€ ticket_card.dart
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â””â”€â”€ constants.dart
â”‚   â”œâ”€â”€ pubspec.yaml
â”‚   â”œâ”€â”€ android/
â”‚   â”œâ”€â”€ ios/
â”‚   â””â”€â”€ assets/
â”‚       â”œâ”€â”€ icons/
â”‚       â””â”€â”€ qr_overlay.png
â”‚
â”‚
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ README.md
â””â”€â”€ .gitignore
```

---

# ğŸ§  3. Workflow (Phase-1 end-to-end)

### Step 1: User Registration

* User fills the **React form** â†’ sends POST to `/register`.
* FastAPI stores it in the `registrations` table with status `pending`.
* Admin dashboard fetches all pending registrations using `/admin/registrations?status=pending`.

---

### Step 2: Admin Approval

* Admin logs into **React Admin Dashboard** â†’ `/login` authenticates via JWT.
* From dashboard:

  * Selects pending registration â†’ clicks **Approve**.
  * Backend:

    * Generates unique serial number (`EVT2025-000123`).
    * Creates a `ticket` entry.
    * Generates QR PNG and stores it under `/uploads/EVT2025-000123.png`.
    * Sends QR via email (future phase).
    * Updates registration `status='approved'`.

---

### Step 3: Ticket Email (optional now)

* (Later) backend emails user QR and serial number link.
  For now: Admin can download or view QR from dashboard.

---

### Step 4: Verification via Flutter App

* Flutter app opens **camera scanning window**.
* Uses package: `mobile_scanner` or `qr_code_scanner`.
* Reads QR â†’ sends GET `/verify-ticket/{serial}`.
* API returns:

  ```json
  {
    "name": "Alice",
    "team_name": "Team X",
    "event_name": "HackFest 2025",
    "status": "approved"
  }
  ```
* Flutter displays ticket info with **â€œContinueâ€** button.

---

### Step 5: Confirm Attendance

* User (gate staff) taps â€œContinueâ€.
* Flutter calls `POST /mark-used/{serial}` â†’ backend marks `used_at` timestamp atomically.
* If ticket already used â†’ backend returns conflict (409) â†’ Flutter displays â€œAlready usedâ€.

---

### Step 6: View Audit Logs

* Admins can view all actions in `/admin/logs` from the `audit_logs` table.

---

# ğŸ§® 4. Database Summary (Quick Map)

| Table           | Purpose                | Key Fields                            |
| --------------- | ---------------------- | ------------------------------------- |
| `registrations` | Store form submissions | `id`, `name`, `email`, `status`       |
| `tickets`       | Issued tickets         | `serial_number`, `qr_path`, `used_at` |
| `attachments`   | Screenshots, uploads   | `file_path`, `file_type`              |
| `admins`        | Admin credentials      | `username`, `password_hash`           |
| `audit_logs`    | All admin actions      | `admin_id`, `action`, `details`       |

---

# ğŸ’» 5. Backend API Routes Overview

| Route                     | Method | Purpose                                 |
| ------------------------- | ------ | --------------------------------------- |
| `/register`               | POST   | User submits form                       |
| `/admin/login`            | POST   | Authenticate admin                      |
| `/admin/registrations`    | GET    | List registrations (filtered by status) |
| `/admin/approve/{id}`     | POST   | Approve registration, generate ticket   |
| `/admin/decline/{id}`     | POST   | Decline registration                    |
| `/verify-ticket/{serial}` | GET    | Verify scanned QR or typed serial       |
| `/mark-used/{serial}`     | POST   | Mark ticket as used                     |
| `/admin/logs`             | GET    | View action logs                        |

---

# ğŸª¶ 6. Frontend React (Vite + Tailwind)

## **Form App**

* Landing: `/`
* Components:

  * `RegistrationForm.jsx`: inputs for name, email, event, team.
  * `SuccessMessage.jsx`: displayed after submit.
* API file (`registrationApi.js`): handles POST calls to backend.
* Tailwind for styling, Toasts for feedback.

## **Admin Dashboard**

* Pages:

  * `/login` â†’ JWT login.
  * `/dashboard` â†’ List registrations + Approve/Decline buttons.
  * `/logs` â†’ Action history.
* Components:

  * `Sidebar`, `Navbar`, `Table`, `ApproveModal`.
* Uses Axios to connect with backend routes.

---

# ğŸ“± 7. Flutter App Details

| Feature                | Description                                                              |
| ---------------------- | ------------------------------------------------------------------------ |
| **scan_page.dart**     | Uses `mobile_scanner` to detect QR, auto-calls `/verify-ticket/{serial}` |
| **manual_entry.dart**  | Input field for serial number (fallback)                                 |
| **verify_result.dart** | Displays details returned from backend and â€œContinueâ€ button             |
| **api_service.dart**   | Handles GET + POST requests to backend                                   |
| **ticket_card.dart**   | UI card showing ticket info visually                                     |
| **constants.dart**     | Holds base URL, color theme, etc.                                        |

Example scan logic:

```dart
onDetect: (barcode, args) async {
  final serial = barcode.rawValue;
  final details = await ApiService.verifyTicket(serial);
  if (details != null) {
    Navigator.push(context, MaterialPageRoute(builder: (_) => VerifyResult(details: details)));
  }
}
```

---

# ğŸ§± 8. Phase-1 Goals Checklist

| Module                 | Target                        | Status |
| ---------------------- | ----------------------------- | ------ |
| Backend core setup     | FastAPI + SQLite              | âœ…      |
| Models & DB schema     | Registrations, Tickets, Admin | âœ…      |
| Form frontend          | React (Vite + Tailwind)       | âœ…      |
| Admin dashboard        | React (Vite + Tailwind)       | âœ…      |
| QR generation logic    | In backend                    | âœ…      |
| Flutter scanner app    | UI + API verify               | âœ…      |
| Atomic mark-used logic | Prevent duplicates            | âœ…      |
| Local file uploads     | `/uploads/` folder            | âœ…      |
| Docker setup           | Compose for all               | âœ…      |

---

# ğŸ›  9. Phase-2 (future upgrades)

| Feature                     | Tool                          |
| --------------------------- | ----------------------------- |
| Emailing QR to participants | SendGrid / Resend API         |
| Cloud DB & file storage     | Supabase / AWS S3             |
| Role-based admin dashboard  | FastAPI permissions           |
| Event multi-tenancy         | Add `event_id` to schema      |
| Analytics dashboard         | Chart.js or Recharts in admin |
| Real-time updates           | WebSockets / Pusher           |
| Flutter offline mode        | Cache QR scans locally        |

---

# âš™ï¸ 10. Example docker-compose.yml

```yaml
version: "3.9"

services:
  backend:
    build: ./backend
    container_name: ticket_backend
    env_file: ./backend/.env
    ports:
      - "8000:8000"
    depends_on:
      - db

  db:
    image: postgres:15
    container_name: ticket_db
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: ticketing
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  db_data:
```

---

# ğŸ§­ 11. Phase-1 Workflow Summary

1. User â†’ fills form â†’ stored in `registrations`.
2. Admin â†’ logs in â†’ views pending list.
3. Admin â†’ approves â†’ backend generates serial + QR â†’ stores in `tickets`.
4. Flutter app â†’ scans QR or enters serial â†’ fetches details.
5. Gate staff â†’ confirms â†’ backend updates `used_at`.
6. Admin â†’ can review logs & ticket usage.

Complete backend code (copy these files into your `backend/` folder):

* `requirements.txt`
* `.env.example`
* `main.py`
* `app/database.py`
* `app/models/`

  * `registration.py`
  * `ticket.py`
  * `admin.py`
  * `attachment.py`
  * `audit_log.py`
* `app/schemas/`

  * `registration_schema.py`
  * `ticket_schema.py`
  * `admin_schema.py`
* `app/routes/`

  * `registration_routes.py`
  * `admin_routes.py`
  * `verify_routes.py`
  * `auth_routes.py`
* `app/utils/`

  * `security.py` (password hashing + JWT)
  * `serial_generator.py`
  * `qr_service.py` (simple PNG generator)
  * `storage.py` (local dev storage helper)
* `app/services/`

  * `ticket_service.py` (wraps generation + DB transaction)
* small `init_db.py` to create tables
* run instructions

Everything uses SQLite by default (local) â€” you can switch `DATABASE_URL` in `.env` to MySQL/Postgres later.

---

## 1) `requirements.txt`

```txt
fastapi>=0.115.0
uvicorn[standard]>=0.32.0
python-multipart>=0.0.12
sqlalchemy>=2.0.36
python-dotenv>=1.0.1
aiosmtplib>=3.0.2
qrcode[pil]>=8.0
Pillow>=11.0.0
pydantic>=2.10.0
pydantic-settings>=2.6.0
pyjwt[crypto]>=2.10.0
passlib[bcrypt]>=1.7.4
```

---

## 2) `.env.example`

Copy to `.env` and edit values for your environment.

```
# .env
DATABASE_URL=sqlite+aiosqlite:///./dev.db
SECRET_KEY=replace_with_a_strong_secret
ACCESS_TOKEN_EXPIRE_MINUTES=1440
ALGORITHM=HS256

# Email (not used in Phase1) kept for future
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=you@example.com
SMTP_PASS=yourpassword
```

> For local SQLite dev we use `sqlite+aiosqlite`. For production change to `postgresql+psycopg2://...` or `mysql+pymysql://...` and update `requirements.txt` for the corresponding DB driver.

---

## 3) `main.py` (backend root)

```python
# backend/main.py
import uvicorn
from fastapi import FastAPI
from app.database import Base, engine
from app.routes import registration_routes, admin_routes, verify_routes, auth_routes
from dotenv import load_dotenv
import os

load_dotenv()

app = FastAPI(title="Event Ticketing API - Phase1")

# create DB tables on startup (dev only)
Base.metadata.create_all(bind=engine)

# include routers
app.include_router(auth_routes.router, prefix="/auth", tags=["auth"])
app.include_router(registration_routes.router, prefix="/register", tags=["registration"])
app.include_router(admin_routes.router, prefix="/admin", tags=["admin"])
app.include_router(verify_routes.router, prefix="/verify", tags=["verify"])


@app.get("/")
def root():
    return {"status": "ok", "message": "Event Ticketing Backend running"}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
```

---

## 4) `app/database.py`

```python
# backend/app/database.py
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./dev.db")

# For simplicity we will use synchronous engine for SQLAlchemy ORM usage in this template.
# If using aiosqlite/asynchronous patterns later adjust accordingly.
engine = create_engine(DATABASE_URL, echo=False, future=True)
SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False, expire_on_commit=False)
Base = declarative_base()

# dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

> Note: Using `create_engine` with `sqlite+aiosqlite` is fine for local dev; if you switch to a server DB, `create_engine` connection URL will adapt. For async SQLAlchemy, more setup is needed â€” this is a pragmatic synchronous setup.

---

## 5) `app/models/registration.py`

```python
# backend/app/models/registration.py
from sqlalchemy import Column, BigInteger, String, Text, Numeric, TIMESTAMP, func
from sqlalchemy.orm import relationship
from app.database import Base

class Registration(Base):
    __tablename__ = "registrations"
    id = Column(BigInteger, primary_key=True)
    name = Column(String(255), nullable=False)
    email = Column(String(255), nullable=False, index=True)
    phone = Column(String(32))
    team_name = Column(String(255))
    members = Column(Text)          # store JSON string or CSV
    event_name = Column(String(255), nullable=False, default="default_event")
    amount = Column(Numeric(10,2), nullable=True)
    status = Column(String(20), nullable=False, default="pending", index=True)
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now())

    # relationships
    ticket = relationship("Ticket", back_populates="registration", uselist=False)
    attachments = relationship("Attachment", back_populates="registration")
```

---

## 6) `app/models/ticket.py`

```python
# backend/app/models/ticket.py
from sqlalchemy import Column, BigInteger, String, ForeignKey, TIMESTAMP, func
from sqlalchemy.orm import relationship
from app.database import Base

class Ticket(Base):
    __tablename__ = "tickets"
    id = Column(BigInteger, primary_key=True)
    registration_id = Column(BigInteger, ForeignKey("registrations.id", ondelete="CASCADE"), nullable=False, unique=True)
    serial_number = Column(String(64), unique=True, nullable=False, index=True)
    qr_path = Column(String(1024))
    issued_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
    used_at = Column(TIMESTAMP(timezone=True), nullable=True)

    registration = relationship("Registration", back_populates="ticket")
```

---

## 7) `app/models/attachment.py`

```python
# backend/app/models/attachment.py
from sqlalchemy import Column, BigInteger, String, ForeignKey, TIMESTAMP, func
from sqlalchemy.orm import relationship
from app.database import Base

class Attachment(Base):
    __tablename__ = "attachments"
    id = Column(BigInteger, primary_key=True)
    registration_id = Column(BigInteger, ForeignKey("registrations.id", ondelete="CASCADE"), nullable=False)
    file_path = Column(String(1024), nullable=False)
    file_type = Column(String(64))
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())

    registration = relationship("Registration", back_populates="attachments")
```

---

## 8) `app/models/admin.py`

```python
# backend/app/models/admin.py
from sqlalchemy import Column, BigInteger, String, TIMESTAMP, func
from app.database import Base

class Admin(Base):
    __tablename__ = "admins"
    id = Column(BigInteger, primary_key=True)
    username = Column(String(150), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    role = Column(String(50), default="admin")
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
```

---

## 9) `app/models/audit_log.py`

```python
# backend/app/models/audit_log.py
from sqlalchemy import Column, BigInteger, String, ForeignKey, TIMESTAMP, JSON
from sqlalchemy.orm import relationship
from app.database import Base
from sqlalchemy.sql import func

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(BigInteger, primary_key=True)
    admin_id = Column(BigInteger, ForeignKey("admins.id"), nullable=True)
    registration_id = Column(BigInteger, ForeignKey("registrations.id"), nullable=True)
    action = Column(String(64), nullable=False)
    details = Column(JSON, nullable=True)
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
```

---

## 10) `app/schemas/registration_schema.py`

```python
# backend/app/schemas/registration_schema.py
from pydantic import BaseModel, EmailStr
from typing import Optional, List

class RegistrationCreate(BaseModel):
    name: str
    email: EmailStr
    phone: Optional[str] = None
    team_name: Optional[str] = None
    members: Optional[str] = None   # or JSON stringified
    event_name: Optional[str] = "default_event"
    amount: Optional[float] = None

class RegistrationOut(BaseModel):
    id: int
    name: str
    email: EmailStr
    phone: Optional[str]
    team_name: Optional[str]
    members: Optional[str]
    event_name: str
    amount: Optional[float]
    status: str

    class Config:
        orm_mode = True
```

---

## 11) `app/schemas/ticket_schema.py`

```python
# backend/app/schemas/ticket_schema.py
from pydantic import BaseModel
from typing import Optional

class TicketOut(BaseModel):
    serial_number: str
    qr_path: Optional[str]
    issued_at: Optional[str]
    used_at: Optional[str]

    class Config:
        orm_mode = True
```

---

## 12) `app/schemas/admin_schema.py`

```python
# backend/app/schemas/admin_schema.py
from pydantic import BaseModel

class AdminLogin(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"
```

---

## 13) `app/utils/security.py` (hashing + JWT)

```python
# backend/app/utils/security.py
import os
from datetime import datetime, timedelta
from passlib.context import CryptContext
import jwt

PWD_CTX = CryptContext(schemes=["bcrypt"], deprecated="auto")
SECRET_KEY = os.getenv("SECRET_KEY", "dev_secret")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "1440"))

def hash_password(password: str) -> str:
    return PWD_CTX.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return PWD_CTX.verify(plain, hashed)

def create_access_token(data: dict, expires_delta: int = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=(expires_delta or ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    encoded = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded

def decode_access_token(token: str):
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.PyJWTError:
        return None
```

---

## 14) `app/utils/serial_generator.py`

```python
# backend/app/utils/serial_generator.py
from typing import Optional

def format_serial(prefix: str, numeric_id: int, width: int = 6) -> str:
    return f"{prefix}-{numeric_id:0{width}d}"

# Example usage:
# format_serial("EVT2025", 123) -> "EVT2025-000123"
```

---

## 15) `app/utils/qr_service.py`

```python
# backend/app/utils/qr_service.py
import qrcode
from pathlib import Path

UPLOAD_DIR = Path("app/static/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

def generate_qr_png(serial: str) -> str:
    """Generate QR PNG for given serial and return local path string."""
    filename = f"{serial}.png"
    path = UPLOAD_DIR / filename
    img = qrcode.make(serial)
    img.save(path)
    return str(path)
```

---

## 16) `app/utils/storage.py` (simple local helper)

```python
# backend/app/utils/storage.py
from pathlib import Path
from fastapi import UploadFile

UPLOAD_DIR = Path("app/static/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

def save_upload(file: UploadFile, dest_name: str) -> str:
    dest = UPLOAD_DIR / dest_name
    with dest.open("wb") as f:
        content = file.file.read()
        f.write(content)
    return str(dest)
```

---

## 17) `app/services/ticket_service.py`

```python
# backend/app/services/ticket_service.py
from sqlalchemy.orm import Session
from app.models.ticket import Ticket
from app.models.registration import Registration
from app.utils.serial_generator import format_serial
from app.utils.qr_service import generate_qr_png
from app.models.audit_log import AuditLog
from datetime import datetime

def issue_ticket(db: Session, registration_id: int, prefix="EVT2025") -> Ticket:
    # create ticket row with a placeholder serial; we'll commit and then generate final serial
    reg = db.get(Registration, registration_id)
    if not reg:
        raise ValueError("Registration not found")

    # ensure only one ticket per registration
    if reg.ticket:
        return reg.ticket

    ticket = Ticket(registration_id=registration_id, serial_number="TEMP")
    db.add(ticket)
    db.flush()  # assigns ticket.id

    # create final human serial
    human_serial = format_serial(prefix, ticket.id)
    ticket.serial_number = human_serial

    # generate QR
    qr_path = generate_qr_png(human_serial)
    ticket.qr_path = qr_path
    ticket.issued_at = datetime.utcnow()

    # update registration status
    reg.status = "approved"

    # add audit log (optional)
    audit = AuditLog(admin_id=None, registration_id=registration_id, action="approve", details={"serial": human_serial})
    db.add(audit)

    db.commit()
    db.refresh(ticket)
    return ticket
```

---

## 18) `app/routes/registration_routes.py`

```python
# backend/app/routes/registration_routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.database import get_db
from app.schemas.registration_schema import RegistrationCreate, RegistrationOut
from app.models.registration import Registration

router = APIRouter()

@router.post("/", response_model=dict)
def create_registration(payload: RegistrationCreate, db: Session = Depends(get_db)):
    # basic duplicate email check (optional)
    existing = db.query(Registration).filter(Registration.email == payload.email).first()
    if existing:
        # we still allow duplicate but could prevent:
        # raise HTTPException(status_code=400, detail="Email already registered")
        pass

    reg = Registration(
        name=payload.name,
        email=payload.email,
        phone=payload.phone,
        team_name=payload.team_name,
        members=payload.members,
        event_name=payload.event_name,
        amount=payload.amount,
        status="pending"
    )
    db.add(reg)
    db.commit()
    db.refresh(reg)
    return {"message": "Registration successful", "id": reg.id}
```

---

## 19) `app/routes/auth_routes.py`

```python
# backend/app/routes/auth_routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.database import get_db
from app.models.admin import Admin
from app.schemas.admin_schema import AdminLogin, Token
from app.utils.security import verify_password, create_access_token

router = APIRouter()

@router.post("/login", response_model=dict)
def admin_login(payload: AdminLogin, db: Session = Depends(get_db)):
    user = db.query(Admin).filter(Admin.username == payload.username).first()
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    if not verify_password(payload.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_access_token({"sub": user.username, "role": user.role})
    return {"access_token": token, "token_type": "bearer"}
```

> NOTE: For now admin user must be created manually via DB or via a small utility. Iâ€™ll provide a snippet below to create initial admin.

---

## 20) `app/routes/admin_routes.py`

```python
# backend/app/routes/admin_routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.database import get_db
from app.models.registration import Registration
from app.services.ticket_service import issue_ticket

router = APIRouter()

@router.get("/registrations")
def list_registrations(status: str = None, db: Session = Depends(get_db)):
    q = db.query(Registration).order_by(Registration.created_at.desc())
    if status:
        q = q.filter(Registration.status == status)
    rows = q.all()
    return rows

@router.post("/approve/{registration_id}")
def approve_registration(registration_id: int, db: Session = Depends(get_db)):
    reg = db.get(Registration, registration_id)
    if not reg:
        raise HTTPException(status_code=404, detail="Registration not found")
    # issue ticket (transaction handled in service)
    ticket = issue_ticket(db, registration_id)
    return {"status": "approved", "serial": ticket.serial_number, "qr_path": ticket.qr_path}

@router.post("/decline/{registration_id}")
def decline_registration(registration_id: int, reason: str = None, db: Session = Depends(get_db)):
    reg = db.get(Registration, registration_id)
    if not reg:
        raise HTTPException(status_code=404, detail="Registration not found")
    reg.status = "declined"
    db.commit()
    return {"status": "declined"}
```

---

## 21) `app/routes/verify_routes.py`

```python
# backend/app/routes/verify_routes.py
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from app.database import get_db
from app.models.ticket import Ticket
from app.models.registration import Registration
from app.database import SessionLocal
from sqlalchemy import update
from sqlalchemy.sql import func

router = APIRouter()

@router.get("/ticket/{serial}")
def verify_ticket(serial: str, db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.serial_number == serial).first()
    if not ticket:
        raise HTTPException(status_code=404, detail="Ticket not found")
    reg = db.get(Registration, ticket.registration_id)
    return {
        "status": "valid" if not ticket.used_at else "used",
        "serial": ticket.serial_number,
        "name": reg.name,
        "email": reg.email,
        "team_name": reg.team_name,
        "event_name": reg.event_name,
        "issued_at": str(ticket.issued_at),
        "used_at": str(ticket.used_at) if ticket.used_at else None
    }

@router.post("/mark-used/{serial}")
def mark_used(serial: str, db: Session = Depends(get_db)):
    # atomic update: set used_at only if it is currently NULL
    stmt = update(Ticket).where(Ticket.serial_number == serial, Ticket.used_at.is_(None)).values(used_at=func.now())
    res = db.execute(stmt)
    db.commit()
    if res.rowcount == 0:
        raise HTTPException(status_code=409, detail="Ticket not found or already used")
    return {"status": "success", "serial": serial}
```

---

## 22) `init_db.py` â€” create initial admin user (run once)

Create this small script to add an initial admin (use it once to seed admin user).

```python
# backend/init_db.py
from app.database import SessionLocal, Base, engine
from app.models.admin import Admin
from app.utils.security import hash_password
Base.metadata.create_all(bind=engine)

def create_admin(username: str, password: str):
    db = SessionLocal()
    try:
        if db.query(Admin).filter(Admin.username==username).first():
            print("admin exists")
            return
        hashed = hash_password(password)
        admin = Admin(username=username, password_hash=hashed)
        db.add(admin)
        db.commit()
        print("Admin created.")
    finally:
        db.close()

if __name__ == "__main__":
    create_admin("admin", "adminpass123")
```

Run once:

```bash
python backend/init_db.py
```

Then use username `admin` and password `adminpass123` to test admin login (change password before production).

---

## 23) How to run locally (step-by-step)

1. Create project folder `event-ticketing-system/` and inside a `backend/` folder. Copy files as described above preserving paths.

2. Create virtualenv and install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate      # mac/linux
# or .venv\Scripts\activate    # windows
pip install -r backend/requirements.txt
```

3. Copy `.env.example` â†’ `backend/.env` and edit if needed.

4. Initialize DB and create admin:

```bash
python backend/init_db.py
```

5. Start the server:

```bash
cd backend
uvicorn main:app --reload --port 8000
```

6. Test endpoints:

* `POST http://127.0.0.1:8000/register/` with JSON body (see schema)
* `GET  http://127.0.0.1:8000/admin/registrations`
* `POST http://127.0.0.1:8000/admin/approve/{id}`
* `GET  http://127.0.0.1:8000/verify/ticket/{serial}`
* `POST http://127.0.0.1:8000/verify/mark-used/{serial}`

---

## 24) Notes, considerations & next steps

* **Storage:** currently QR images and uploads live under `app/static/uploads/`. For production switch to S3/Supabase and store URLs in DB.
* **Auth:** Admin login returns JWT. You should wire dependency `get_current_admin()` in admin routes to require tokens. For Phase 1 we kept it lightweight.
* **Concurrency:** `mark_used` uses an atomic SQL UPDATE (checks `used_at IS NULL`) to prevent double-scan race conditions.
* **Validation:** Pydantic schemas provide basic validation. Add stronger validation for phone, email formats if needed.
* **Migrations:** Add Alembic later for DB schema changes â€” I included `alembic/` in structure above.
* **Email:** `aiosmtplib` is in `requirements.txt`. Email sending will be implemented in Phase 2 (`app/services/email_service.py`).
* **Logging:** Add structured logging (e.g., `structlog` or `logging` module) before production.


## âš™ï¸ Updated Tech Stack (Phase 1 â€“ Local with MySQL)

| Component                   | Technology                                        | Purpose                          |
| --------------------------- | ------------------------------------------------- | -------------------------------- |
| **Frontend (Admin + Form)** | React + Vite + TypeScript                         | Fast modern web UI               |
| **Mobile/Desktop App**      | Flutter 3 + Dart                                  | QR scanning + check-in           |
| **Backend**                 | FastAPI (Python 3.11+)                            | REST API backend                 |
| **Database**                | MySQL (local, e.g. XAMPP/WAMP or Docker)          | Persistent data store            |
| **ORM**                     | SQLAlchemy + Pydantic + Alembic                   | Models + validation + migrations |
| **QR Code**                 | `qrcode` (Python) + `qr_flutter` (Dart)           | QR generation + scan             |
| **UI Frameworks**           | Tailwind CSS (React) â€¢ Material 3 (Flutter)       | Consistent design                |
| **State Management**        | React Context/Zustand â€¢ Flutter Provider/Riverpod | Data flow                        |
| **Tools**                   | Docker (optional), Git                            | Dev + version control            |

---

## ğŸ—‚ï¸ Folder Structure (Revised)

```
project-root/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ participant.py
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ participant_routes.py
â”‚   â”œâ”€â”€ database.py
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â””â”€â”€ participant_schema.py
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ qr_generator.py
â”‚   â”œâ”€â”€ alembic/                   # Migrations
â”‚   â””â”€â”€ requirements.txt
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ admin-dashboard/
â”‚   â”‚   â””â”€â”€ src/...
â”‚   â””â”€â”€ form/
â”‚       â””â”€â”€ src/...
â”‚
â””â”€â”€ flutter_app/
    â””â”€â”€ lib/...
```

---

## ğŸ§  MySQL Database Design

**Database name:** `event_management`

### Table: `participants`

| Column          | Type                                                 | Description          |
| --------------- | ---------------------------------------------------- | -------------------- |
| `id`            | INT PK AUTO_INCREMENT                                | Unique ID            |
| `name`          | VARCHAR(100)                                         | Full name            |
| `email`         | VARCHAR(100) UNIQUE                                  | Email address        |
| `serial_number` | VARCHAR(50) UNIQUE                                   | Serial/QR identifier |
| `status`        | ENUM('registered','checked_in') DEFAULT 'registered' | Current status       |
| `check_in_time` | DATETIME NULL                                        | Time of check-in     |
| `qr_code_path`  | VARCHAR(255) NULL                                    | Stored QR path       |

---

## ğŸ§© Backend Configuration

### `database.py`

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

# Local MySQL connection (XAMPP/WAMP)
DATABASE_URL = "mysql+pymysql://root:@localhost/event_management"

engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)
Base = declarative_base()
```

### `models/participant.py`

```python
from sqlalchemy import Column, Integer, String, Enum, DateTime
from datetime import datetime
from ..database import Base
import enum

class StatusEnum(str, enum.Enum):
    registered = "registered"
    checked_in = "checked_in"

class Participant(Base):
    __tablename__ = "participants"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    serial_number = Column(String(50), unique=True, nullable=False)
    status = Column(Enum(StatusEnum), default=StatusEnum.registered)
    check_in_time = Column(DateTime, nullable=True)
    qr_code_path = Column(String(255), nullable=True)
```

### `routes/participant_routes.py`

Endpoints:

* `POST /register` â†’ add participant + generate QR
* `GET /participants` â†’ list all participants
* `GET /participants/{serial_number}` â†’ lookup by QR/serial
* `PUT /checkin/{serial_number}` â†’ mark checked-in

---

## ğŸ§­ Workflow Recap (MySQL-backed)

1ï¸âƒ£ **User Form (React form app)**
â†’ Calls FastAPI `/register` â†’ inserts participant into MySQL + generates QR.

2ï¸âƒ£ **Admin Dashboard**
â†’ Fetches from `/participants` â†’ shows registered vs checked-in, allows export.

3ï¸âƒ£ **Flutter Check-In App**
â†’ Scans QR (serial number) â†’ `GET /participants/{serial_number}`
â†’ Shows details â†’ â€œConfirm Check-Inâ€ â†’ `PUT /checkin/{serial_number}`.
â†’ Falls back to manual serial number input if QR fails.

4ï¸âƒ£ **Backend**
â†’ Updates MySQL row `status = 'checked_in'`, sets `check_in_time = NOW()`.

---

## ğŸ§© Data Flow Diagram

```
[ Form App ] â†’ POST /register â†’ [ FastAPI + MySQL ] â† GET/PUT â†’ [ Flutter App (QR) ]
                                          â†‘
                                          â”‚
                                  [ Admin Dashboard ]
```

---

## âœ… Development Plan (in order)

1. **MySQL setup:**

   * Create DB `event_management`.
   * Run Alembic migrations (`alembic init`, `alembic revision --autogenerate`, `alembic upgrade head`).

2. **Backend core:**

   * Implement FastAPI models, schemas, routes.
   * Test endpoints via Postman.

3. **Frontend (Vite React):**

   * Create admin-dashboard & form apps.
   * Integrate API endpoints.

4. **Flutter app:**

   * Implement QR scan + manual input.
   * Connect to backend API.

5. **Integration test:**

   * Register â†’ Scan â†’ Check-In â†’ Dashboard update.

